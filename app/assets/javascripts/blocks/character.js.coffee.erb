# 「キャラクター」ジャンル

<%
  category = 'character'
  color = 198
%>

# キャラクター
<% n = "#{category}_new" %>
Blockly.Blocks['<%= n %>'] =
  init: ->
    @setHelpUrl('')
    @setColour(<%= color %>)

    size = Blockly.BlockSvg.FIELD_HEIGHT * 2
    imageField = new Blockly.FieldImage(null, size, size)

    nameField = new Blockly.FieldLabel('')
    # HACK: ラベルをXMLとして出力させるためにEDITABLEをtrueにしている
    nameField.EDITABLE = true
    # HACK: 画像とラベルの縦位置を合わせる
    nameField.textElement_.setAttribute('y', 10)
    nameField.setText = _.bind(@nameFieldSetText_, @)

    @appendDummyInput()
      .appendField(imageField, 'COSTUME')
      .appendField(nameField, 'NAME')
    @appendStatementInput('DO')
    @setPreviousStatement(true)
    @setNextStatement(true)
    @setTooltip('')

  dispose: (healStack, animate) ->
    @character.unlink?(@)
    Blockly.Block.prototype.dispose.apply(@, arguments)

  nameFieldSetText_: (name) ->
    charSet = Smalruby.Collections.CharacterSet
    char = charSet.findWhere({ name: name })
    if char
      @setCharacter(char)
    else
      @fieldLableSetText_(@getField_('NAME'), name)

  fieldLableSetText_: (field, text) ->
    Blockly.FieldLabel.prototype.setText.call(field, text)

  setCharacter: (character) ->
    @character = character
    @setFieldValue(character.costumeUrl(), 'COSTUME')
    @fieldLableSetText_(@getField_('NAME'), character.get('name'))
    character.link(@)

    character.on 'change', (model) =>
      @setFieldValue(model.costumeUrl(), 'COSTUME')
      @fieldLableSetText_(@getField_('NAME'), character.get('name'))

    @

Blockly.Ruby['<%= n %>'] = (block) ->
  c = block.character
  Blockly.Ruby.cs_().push(c)
  try
    targetBlock = block.getInputTargetBlock('DO')
    branch = Blockly.Ruby.blockToCode(targetBlock) || '\n'
  finally
    Blockly.Ruby.cs_().pop()
  """
  #{c.get('name')} = Character.new(costume: #{Blockly.Ruby.quote_(c.costume())}, x: #{c.get('x')}, y: #{c.get('y')}, angle: #{c.get('angle')})
  #{branch}
  """
